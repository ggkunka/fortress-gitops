"""
Vulnerability Feed Connector - Integration with Vulnerability Management Systems

This connector provides integration capabilities with vulnerability databases
and management platforms for enriching vulnerability data and tracking remediation.
"""

import asyncio
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import httpx
from urllib.parse import urljoin

from shared.observability.logging import get_logger
from shared.observability.metrics import get_metrics
from shared.observability.tracing import traced

from ..models.integration import Integration

logger = get_logger(__name__)
metrics = get_metrics()


class VulnerabilityFeedConnector:
    """
    Vulnerability feed connector supporting multiple vulnerability databases and platforms.
    
    Supported vulnerability platforms:
    - National Vulnerability Database (NVD)
    - CVE Details
    - VulnDB
    - Tenable.io
    - Qualys VMDR
    - Rapid7 InsightVM
    - OpenVAS
    - Nessus
    - Snyk
    - WhiteSource (Mend)
    - GitHub Security Advisories
    - Custom vulnerability feeds
    """
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(timeout=30.0)
        self.supported_providers = {
            "nvd": self._handle_nvd,
            "cve_details": self._handle_cve_details,
            "vulndb": self._handle_vulndb,
            "tenable": self._handle_tenable,
            "qualys": self._handle_qualys,
            "rapid7": self._handle_rapid7,
            "openvas": self._handle_openvas,
            "nessus": self._handle_nessus,
            "snyk": self._handle_snyk,
            "mend": self._handle_mend,
            "github": self._handle_github_advisories,
            "custom": self._handle_custom_vuln_feed
        }
        
        # Rate limiting for public APIs
        self.rate_limits = {
            "nvd": {"requests_per_minute": 50, "last_request": None, "request_count": 0},
            "github": {"requests_per_minute": 60, "last_request": None, "request_count": 0}
        }
        
        logger.info("Vulnerability feed connector initialized")
    
    @traced("vulnerability_feed_connector_connect")
    async def connect(self, integration: Integration) -> Dict[str, Any]:
        """Establish connection to vulnerability platform."""
        try:
            provider = integration.provider.lower()
            if provider not in self.supported_providers:
                return {
                    "success": False,
                    "error": f"Unsupported vulnerability provider: {provider}",
                    "provider": provider
                }
            
            # Get provider-specific handler
            handler = self.supported_providers[provider]
            
            # Attempt connection
            start_time = datetime.now()
            result = await handler("connect", integration)
            response_time = (datetime.now() - start_time).total_seconds() * 1000
            
            result.update({
                "response_time": response_time,
                "provider": provider,
                "connected_at": datetime.now().isoformat()
            })
            
            if result.get("success"):
                logger.info(f"Successfully connected to {provider} vulnerability feed: {integration.name}")
                metrics.vulnerability_feed_connector_connections_successful.inc()
            else:
                logger.error(f"Failed to connect to {provider} vulnerability feed: {integration.name}")
                metrics.vulnerability_feed_connector_connections_failed.inc()
            
            return result
            
        except Exception as e:
            logger.error(f"Error connecting to vulnerability feed {integration.name}: {e}")
            metrics.vulnerability_feed_connector_errors.inc()
            return {
                "success": False,
                "error": str(e),
                "error_type": type(e).__name__
            }
    
    @traced("vulnerability_feed_connector_health_check")
    async def health_check(self, integration: Integration) -> Dict[str, Any]:
        """Perform health check on vulnerability feed connection."""
        try:
            provider = integration.provider.lower()
            handler = self.supported_providers.get(provider)
            
            if not handler:
                return {"healthy": False, "error": "Unsupported provider"}
            
            start_time = datetime.now()
            result = await handler("health_check", integration)
            response_time = (datetime.now() - start_time).total_seconds() * 1000
            
            result.update({
                "response_time": response_time,
                "checked_at": datetime.now().isoformat()
            })
            
            metrics.vulnerability_feed_connector_health_checks.inc()
            return result
            
        except Exception as e:
            logger.error(f"Error checking vulnerability feed health {integration.name}: {e}")
            return {
                "healthy": False,
                "error": str(e),
                "error_type": type(e).__name__
            }
    
    @traced("vulnerability_feed_connector_pull_data")
    async def pull_data(self, integration: Integration) -> Dict[str, Any]:
        """Pull vulnerability data from feed."""
        try:
            provider = integration.provider.lower()
            handler = self.supported_providers.get(provider)
            
            if not handler:
                return {"success": False, "error": "Unsupported provider"}
            
            result = await handler("pull_data", integration)
            
            if result.get("success"):
                logger.info(f"Successfully pulled vulnerability data from {provider}: {integration.name}")
                metrics.vulnerability_feed_connector_data_pulls_successful.inc()
            else:
                logger.error(f"Failed to pull vulnerability data from {provider}: {integration.name}")
                metrics.vulnerability_feed_connector_data_pulls_failed.inc()
            
            return result
            
        except Exception as e:
            logger.error(f"Error pulling vulnerability data from {integration.name}: {e}")
            return {
                "success": False,
                "error": str(e),
                "records_processed": 0
            }
    
    @traced("vulnerability_feed_connector_push_data")
    async def push_data(self, integration: Integration, data: Dict[str, Any]) -> Dict[str, Any]:
        """Push vulnerability data to platform (if supported)."""
        try:
            provider = integration.provider.lower()
            handler = self.supported_providers.get(provider)
            
            if not handler:
                return {"success": False, "error": "Unsupported provider"}
            
            result = await handler("push_data", integration, data)
            
            if result.get("success"):
                logger.info(f"Successfully pushed vulnerability data to {provider}: {integration.name}")
                metrics.vulnerability_feed_connector_data_pushes_successful.inc()
            else:
                logger.error(f"Failed to push vulnerability data to {provider}: {integration.name}")
                metrics.vulnerability_feed_connector_data_pushes_failed.inc()
            
            return result
            
        except Exception as e:
            logger.error(f"Error pushing vulnerability data to {integration.name}: {e}")
            return {
                "success": False,
                "error": str(e),
                "records_processed": 0
            }
    
    @traced("vulnerability_feed_connector_send_event")
    async def send_event(self, integration: Integration, event_type: str, event_data: Dict[str, Any]):
        """Send vulnerability event to platform."""
        try:
            provider = integration.provider.lower()
            handler = self.supported_providers.get(provider)
            
            if not handler:
                logger.warning(f"Cannot send event to unsupported vulnerability provider: {provider}")
                return
            
            # Format event for vulnerability platform
            formatted_event = self._format_event_for_vuln_platform(provider, event_type, event_data)
            
            result = await handler("send_event", integration, formatted_event)
            
            if result.get("success"):
                logger.info(f"Successfully sent {event_type} event to {provider} vulnerability platform")
                metrics.vulnerability_feed_connector_events_sent.inc()
            else:
                logger.error(f"Failed to send {event_type} event to {provider} vulnerability platform")
                metrics.vulnerability_feed_connector_events_failed.inc()
            
        except Exception as e:
            logger.error(f"Error sending event to vulnerability platform {integration.name}: {e}")
            metrics.vulnerability_feed_connector_errors.inc()
    
    async def test_connection(self, integration: Integration) -> Dict[str, Any]:
        """Test vulnerability platform connection."""
        return await self.health_check(integration)
    
    async def disconnect(self, integration: Integration):
        """Disconnect from vulnerability platform."""
        try:
            provider = integration.provider.lower()
            logger.info(f"Disconnected from {provider} vulnerability feed: {integration.name}")
            
        except Exception as e:
            logger.error(f"Error disconnecting from vulnerability feed {integration.name}: {e}")
    
    # Provider-specific handlers
    
    async def _handle_nvd(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle National Vulnerability Database (NVD) operations."""
        try:
            config = integration.config
            credentials = integration.credentials
            
            api_key = credentials.get("api_key")  # Optional for NVD
            base_url = "https://services.nvd.nist.gov/rest/json"
            
            headers = {"Content-Type": "application/json"}
            if api_key:
                headers["apiKey"] = api_key
            
            # Rate limiting check
            await self._check_rate_limit("nvd")
            
            if action == "connect":
                # Test connection by getting CVE data
                response = await self.http_client.get(
                    f"{base_url}/cves/2.0",
                    headers=headers,
                    params={"resultsPerPage": 1}
                )
                
                if response.status_code == 200:
                    return {
                        "success": True,
                        "api_version": "2.0",
                        "capabilities": ["cve_lookup", "cpe_lookup", "vulnerability_search"],
                        "supports_pull": True,
                        "supports_push": False,  # NVD is read-only
                        "rate_limited": api_key is None
                    }
                else:
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}: {response.text}"
                    }
            
            elif action == "health_check":
                response = await self.http_client.get(
                    f"{base_url}/cves/2.0",
                    headers=headers,
                    params={"resultsPerPage": 1}
                )
                
                return {
                    "healthy": response.status_code == 200,
                    "status_code": response.status_code,
                    "health_data": {"api_accessible": response.status_code == 200}
                }
            
            elif action == "pull_data":
                # Pull recent CVEs from NVD
                days_back = config.get("days_back", 1)
                results_per_page = min(config.get("max_results", 100), 2000)  # NVD limit
                
                # Calculate date range
                end_date = datetime.now()
                start_date = end_date - timedelta(days=days_back)
                
                params = {
                    "resultsPerPage": results_per_page,
                    "pubStartDate": start_date.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
                    "pubEndDate": end_date.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
                }
                
                response = await self.http_client.get(
                    f"{base_url}/cves/2.0",
                    headers=headers,
                    params=params
                )
                
                if response.status_code == 200:
                    cve_data = response.json()
                    vulnerabilities = cve_data.get("vulnerabilities", [])
                    
                    return {
                        "success": True,
                        "records_processed": len(vulnerabilities),
                        "records_successful": len(vulnerabilities),
                        "records_failed": 0,
                        "data": vulnerabilities,
                        "metadata": {
                            "total_results": cve_data.get("totalResults", 0),
                            "results_per_page": cve_data.get("resultsPerPage", 0),
                            "start_index": cve_data.get("startIndex", 0)
                        }
                    }
                else:
                    return {"success": False, "error": f"Failed to retrieve CVEs: {response.text}"}
            
            elif action == "disconnect":
                return {"success": True}
            
            else:
                return {"success": False, "error": f"Action {action} not supported for NVD"}
                
        except Exception as e:
            logger.error(f"Error in NVD handler: {e}")
            return {"success": False, "error": str(e)}
    
    async def _handle_github_advisories(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle GitHub Security Advisories operations."""
        try:
            credentials = integration.credentials
            config = integration.config
            
            token = credentials.get("token")
            base_url = "https://api.github.com"
            
            headers = {"Accept": "application/vnd.github.v3+json"}
            if token:
                headers["Authorization"] = f"token {token}"
            
            # Rate limiting check
            await self._check_rate_limit("github")
            
            if action == "connect":
                # Test connection by getting user info (if authenticated) or rate limit info
                test_url = f"{base_url}/user" if token else f"{base_url}/rate_limit"
                
                response = await self.http_client.get(test_url, headers=headers)
                
                if response.status_code == 200:
                    return {
                        "success": True,
                        "authenticated": token is not None,
                        "capabilities": ["security_advisories", "vulnerability_alerts"],
                        "supports_pull": True,
                        "supports_push": False,  # GitHub advisories are read-only
                        "rate_limit": response.headers.get("X-RateLimit-Limit")
                    }
                else:
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}: {response.text}"
                    }
            
            elif action == "health_check":
                response = await self.http_client.get(
                    f"{base_url}/rate_limit",
                    headers=headers
                )
                
                return {
                    "healthy": response.status_code == 200,
                    "status_code": response.status_code,
                    "health_data": response.json() if response.status_code == 200 else {}
                }
            
            elif action == "pull_data":
                # Pull recent security advisories
                per_page = min(config.get("max_results", 50), 100)  # GitHub limit
                
                params = {
                    "per_page": per_page,
                    "sort": "published",
                    "direction": "desc"
                }
                
                # Add date filter if specified
                days_back = config.get("days_back")
                if days_back:
                    since_date = (datetime.now() - timedelta(days=days_back)).isoformat()
                    params["since"] = since_date
                
                response = await self.http_client.get(
                    f"{base_url}/advisories",
                    headers=headers,
                    params=params
                )
                
                if response.status_code == 200:
                    advisories = response.json()
                    
                    return {
                        "success": True,
                        "records_processed": len(advisories),
                        "records_successful": len(advisories),
                        "records_failed": 0,
                        "data": advisories,
                        "metadata": {
                            "rate_limit_remaining": response.headers.get("X-RateLimit-Remaining"),
                            "rate_limit_reset": response.headers.get("X-RateLimit-Reset")
                        }
                    }
                else:
                    return {"success": False, "error": f"Failed to retrieve advisories: {response.text}"}
            
            elif action == "disconnect":
                return {"success": True}
            
            else:
                return {"success": False, "error": f"Action {action} not supported for GitHub"}
                
        except Exception as e:
            logger.error(f"Error in GitHub handler: {e}")
            return {"success": False, "error": str(e)}
    
    async def _handle_tenable(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Tenable.io operations."""
        try:
            credentials = integration.credentials
            config = integration.config
            
            access_key = credentials.get("access_key")
            secret_key = credentials.get("secret_key")
            base_url = config.get("url", "https://cloud.tenable.com")
            
            if not access_key or not secret_key:
                return {"success": False, "error": "Tenable access key and secret key required"}
            
            headers = {
                "X-ApiKeys": f"accessKey={access_key}; secretKey={secret_key}",
                "Content-Type": "application/json"
            }
            
            if action == "connect":
                # Test connection by getting user info
                response = await self.http_client.get(
                    f"{base_url}/users",
                    headers=headers
                )
                
                if response.status_code == 200:
                    return {
                        "success": True,
                        "capabilities": ["scans", "vulnerabilities", "assets", "compliance"],
                        "supports_pull": True,
                        "supports_push": False,  # Tenable is primarily read-only via API
                        "instance_url": base_url
                    }
                else:
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}: {response.text}"
                    }
            
            elif action == "health_check":
                response = await self.http_client.get(
                    f"{base_url}/users",
                    headers=headers
                )
                
                return {
                    "healthy": response.status_code == 200,
                    "status_code": response.status_code,
                    "health_data": {"api_accessible": response.status_code == 200}
                }
            
            elif action == "pull_data":
                # Pull recent vulnerabilities
                days_back = config.get("days_back", 7)
                
                # Get vulnerabilities from recent scans
                params = {
                    "date_range": days_back * 24 * 3600,  # Convert days to seconds
                    "filter.0.filter": "severity",
                    "filter.0.quality": "eq",
                    "filter.0.value": "high,critical"  # Focus on high/critical
                }
                
                response = await self.http_client.get(
                    f"{base_url}/workbenches/vulnerabilities",
                    headers=headers,
                    params=params
                )
                
                if response.status_code == 200:
                    vuln_data = response.json()
                    vulnerabilities = vuln_data.get("vulnerabilities", [])
                    
                    return {
                        "success": True,
                        "records_processed": len(vulnerabilities),
                        "records_successful": len(vulnerabilities),
                        "records_failed": 0,
                        "data": vulnerabilities,
                        "metadata": {
                            "date_range": f"{days_back} days",
                            "total_asset_count": vuln_data.get("total_asset_count", 0),
                            "total_vulnerability_count": vuln_data.get("total_vulnerability_count", 0)
                        }
                    }
                else:
                    return {"success": False, "error": f"Failed to retrieve vulnerabilities: {response.text}"}
            
            elif action == "disconnect":
                return {"success": True}
            
            else:
                return {"success": False, "error": f"Action {action} not supported for Tenable"}
                
        except Exception as e:
            logger.error(f"Error in Tenable handler: {e}")
            return {"success": False, "error": str(e)}
    
    # Placeholder handlers for other providers
    
    async def _handle_cve_details(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle CVE Details operations."""
        return {"success": False, "error": "CVE Details integration not yet implemented"}
    
    async def _handle_vulndb(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle VulnDB operations."""
        return {"success": False, "error": "VulnDB integration not yet implemented"}
    
    async def _handle_qualys(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Qualys VMDR operations."""
        return {"success": False, "error": "Qualys VMDR integration not yet implemented"}
    
    async def _handle_rapid7(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Rapid7 InsightVM operations."""
        return {"success": False, "error": "Rapid7 InsightVM integration not yet implemented"}
    
    async def _handle_openvas(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle OpenVAS operations."""
        return {"success": False, "error": "OpenVAS integration not yet implemented"}
    
    async def _handle_nessus(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Nessus operations."""
        return {"success": False, "error": "Nessus integration not yet implemented"}
    
    async def _handle_snyk(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Snyk operations."""
        return {"success": False, "error": "Snyk integration not yet implemented"}
    
    async def _handle_mend(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle Mend (WhiteSource) operations."""
        return {"success": False, "error": "Mend integration not yet implemented"}
    
    async def _handle_custom_vuln_feed(self, action: str, integration: Integration, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle custom vulnerability feed operations."""
        return {"success": False, "error": "Custom vulnerability feed integration not yet implemented"}
    
    # Helper methods
    
    async def _check_rate_limit(self, provider: str):
        """Check and enforce rate limits for public APIs."""
        if provider not in self.rate_limits:
            return
        
        rate_limit_info = self.rate_limits[provider]
        current_time = datetime.now()
        
        # Reset counter if a minute has passed
        if (rate_limit_info["last_request"] is None or 
            (current_time - rate_limit_info["last_request"]).total_seconds() >= 60):
            rate_limit_info["request_count"] = 0
            rate_limit_info["last_request"] = current_time
        
        # Check if we've exceeded the rate limit
        if rate_limit_info["request_count"] >= rate_limit_info["requests_per_minute"]:
            sleep_time = 60 - (current_time - rate_limit_info["last_request"]).total_seconds()
            if sleep_time > 0:
                logger.info(f"Rate limit reached for {provider}, sleeping for {sleep_time} seconds")
                await asyncio.sleep(sleep_time)
                rate_limit_info["request_count"] = 0
                rate_limit_info["last_request"] = datetime.now()
        
        rate_limit_info["request_count"] += 1
    
    def _format_event_for_vuln_platform(self, provider: str, event_type: str, event_data: Dict[str, Any]) -> Dict[str, Any]:
        """Format event data for specific vulnerability platform."""
        base_event = {
            "timestamp": datetime.now().isoformat(),
            "source": "mcp-security-platform",
            "event_type": event_type,
            "data": event_data
        }
        
        if provider == "tenable":
            return {
                "source": "mcp-security-platform",
                "event_type": event_type,
                "severity": event_data.get("severity", "medium"),
                "description": event_data.get("description", ""),
                "data": base_event
            }
        elif provider in ["nvd", "github"]:
            # These are read-only, format for potential future webhook support
            return {
                "source": "mcp-security-platform",
                "event": event_type,
                "payload": base_event
            }
        else:
            return base_event
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.http_client.aclose()