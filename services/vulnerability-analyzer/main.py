"""
Vulnerability Analyzer Service - Main Application

Advanced vulnerability analysis with trending, baseline comparison, and risk assessment.
"""

import asyncio
import signal
import sys
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import structlog
import uvicorn

from shared.config import get_settings
from shared.event_bus import EventBus, get_event_bus
from shared.observability import setup_logging, setup_metrics, setup_tracing

from .models.analysis_models import (
    AnalysisRequest, AnalysisResult, VulnerabilityTrend, 
    BaselineComparison, AnomalyDetection, RiskAssessment
)
from .services.vulnerability_service import VulnerabilityService
from .services.trend_analyzer import TrendAnalyzer
from .services.baseline_service import BaselineService
from .services.anomaly_detector import AnomalyDetector
from .analyzers.risk_analyzer import RiskAnalyzer
from .analyzers.pattern_analyzer import PatternAnalyzer

# Setup logging
setup_logging()
logger = structlog.get_logger(__name__)

# Configuration
settings = get_settings()

# Global services
vulnerability_service: VulnerabilityService = None
trend_analyzer: TrendAnalyzer = None
baseline_service: BaselineService = None
anomaly_detector: AnomalyDetector = None
risk_analyzer: RiskAnalyzer = None
pattern_analyzer: PatternAnalyzer = None
event_bus: EventBus = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    global (vulnerability_service, trend_analyzer, baseline_service, 
            anomaly_detector, risk_analyzer, pattern_analyzer, event_bus)
    
    logger.info("Starting Vulnerability Analyzer Service")
    
    try:
        # Initialize event bus
        event_bus = get_event_bus()
        await event_bus.connect()
        logger.info("Event bus connected")
        
        # Initialize core services
        vulnerability_service = VulnerabilityService(event_bus=event_bus)
        await vulnerability_service.initialize()
        logger.info("Vulnerability service initialized")
        
        trend_analyzer = TrendAnalyzer(vulnerability_service=vulnerability_service)
        await trend_analyzer.initialize()
        logger.info("Trend analyzer initialized")
        
        baseline_service = BaselineService(vulnerability_service=vulnerability_service)
        await baseline_service.initialize()
        logger.info("Baseline service initialized")
        
        anomaly_detector = AnomalyDetector(
            vulnerability_service=vulnerability_service,
            trend_analyzer=trend_analyzer
        )
        await anomaly_detector.initialize()
        logger.info("Anomaly detector initialized")
        
        # Initialize analyzers
        risk_analyzer = RiskAnalyzer(vulnerability_service=vulnerability_service)
        await risk_analyzer.initialize()
        logger.info("Risk analyzer initialized")
        
        pattern_analyzer = PatternAnalyzer(vulnerability_service=vulnerability_service)
        await pattern_analyzer.initialize()
        logger.info("Pattern analyzer initialized")
        
        # Setup event listeners
        await _setup_event_listeners()
        
        # Start background tasks
        analysis_task = asyncio.create_task(_background_analysis_loop())
        
        # Setup graceful shutdown
        def signal_handler(signum, frame):
            logger.info("Received shutdown signal")
            analysis_task.cancel()
            asyncio.create_task(shutdown())
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        logger.info("Vulnerability Analyzer Service started successfully")
        
        yield
        
    except Exception as e:
        logger.error("Failed to start Vulnerability Analyzer Service", error=str(e))
        raise
    finally:
        # Shutdown
        logger.info("Shutting down Vulnerability Analyzer Service")
        
        # Cancel background tasks
        if 'analysis_task' in locals():
            analysis_task.cancel()
        
        # Cleanup services
        if pattern_analyzer:
            await pattern_analyzer.cleanup()
        if risk_analyzer:
            await risk_analyzer.cleanup()
        if anomaly_detector:
            await anomaly_detector.cleanup()
        if baseline_service:
            await baseline_service.cleanup()
        if trend_analyzer:
            await trend_analyzer.cleanup()
        if vulnerability_service:
            await vulnerability_service.cleanup()
        if event_bus:
            await event_bus.disconnect()
        
        logger.info("Vulnerability Analyzer Service stopped")


async def shutdown():
    """Graceful shutdown."""
    logger.info("Performing graceful shutdown...")
    
    # Cancel all running tasks
    tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
    for task in tasks:
        task.cancel()
    
    # Wait for tasks to complete
    await asyncio.gather(*tasks, return_exceptions=True)


async def _setup_event_listeners():
    """Setup event listeners for scan completion events."""
    if event_bus:
        await event_bus.subscribe("scan.completed", _handle_scan_completed)
        await event_bus.subscribe("vulnerability.detected", _handle_vulnerability_detected)
        logger.info("Event listeners configured")


async def _handle_scan_completed(event_data: dict):
    """Handle scan completion events for analysis."""
    try:
        scan_id = event_data.get("scan_id")
        if scan_id and vulnerability_service:
            # Trigger automatic analysis
            await vulnerability_service.analyze_scan_results(scan_id)
            logger.info("Triggered analysis for completed scan", scan_id=scan_id)
            
    except Exception as e:
        logger.error("Error handling scan completed event", error=str(e))


async def _handle_vulnerability_detected(event_data: dict):
    """Handle vulnerability detection events."""
    try:
        vulnerability_id = event_data.get("vulnerability_id")
        if vulnerability_id and anomaly_detector:
            # Check for anomalies in new vulnerabilities
            await anomaly_detector.check_vulnerability_anomaly(vulnerability_id)
            logger.debug("Checked vulnerability for anomalies", 
                        vulnerability_id=vulnerability_id)
            
    except Exception as e:
        logger.error("Error handling vulnerability detected event", error=str(e))


async def _background_analysis_loop():
    """Background task for continuous analysis."""
    while True:
        try:
            # Run trend analysis
            if trend_analyzer:
                await trend_analyzer.update_trends()
            
            # Update baselines
            if baseline_service:
                await baseline_service.update_baselines()
            
            # Run anomaly detection
            if anomaly_detector:
                await anomaly_detector.detect_anomalies()
            
            # Wait 5 minutes before next cycle
            await asyncio.sleep(300)
            
        except Exception as e:
            logger.error("Error in background analysis loop", error=str(e))
            await asyncio.sleep(60)


# Create FastAPI app
app = FastAPI(
    title="MCP Security Platform - Vulnerability Analyzer",
    description="Advanced vulnerability analysis, trending, and risk assessment",
    version="1.0.0",
    docs_url="/docs" if not settings.is_production else None,
    redoc_url="/redoc" if not settings.is_production else None,
    openapi_url="/openapi.json" if not settings.is_production else None,
    lifespan=lifespan,
)

# Setup observability
setup_metrics(app)
setup_tracing(app)

# Add middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    try:
        health_status = {
            "status": "healthy",
            "version": "1.0.0",
            "timestamp": datetime.utcnow().isoformat(),
            "services": {
                "vulnerability_service": "healthy" if vulnerability_service and vulnerability_service.is_healthy() else "unhealthy",
                "trend_analyzer": "healthy" if trend_analyzer and trend_analyzer.is_healthy() else "unhealthy",
                "baseline_service": "healthy" if baseline_service and baseline_service.is_healthy() else "unhealthy",
                "anomaly_detector": "healthy" if anomaly_detector and anomaly_detector.is_healthy() else "unhealthy",
                "risk_analyzer": "healthy" if risk_analyzer and risk_analyzer.is_healthy() else "unhealthy",
                "pattern_analyzer": "healthy" if pattern_analyzer and pattern_analyzer.is_healthy() else "unhealthy",
                "event_bus": "healthy" if event_bus and event_bus.is_connected() else "unhealthy",
            },
            "analysis_status": {
                "active_analyses": vulnerability_service.get_active_analysis_count() if vulnerability_service else 0,
                "completed_analyses": vulnerability_service.get_completed_analysis_count() if vulnerability_service else 0,
                "trend_data_points": trend_analyzer.get_trend_count() if trend_analyzer else 0,
                "baseline_profiles": baseline_service.get_baseline_count() if baseline_service else 0,
                "detected_anomalies": anomaly_detector.get_anomaly_count() if anomaly_detector else 0,
            }
        }
        
        return JSONResponse(
            status_code=status.HTTP_200_OK,
            content=health_status,
        )
    
    except Exception as e:
        logger.error("Health check failed", error=str(e))
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content={
                "status": "unhealthy",
                "error": str(e),
            },
        )


# Analysis Endpoints

@app.post("/api/v1/analyze", response_model=AnalysisResult)
async def analyze_vulnerabilities(
    request: AnalysisRequest,
    background_tasks: BackgroundTasks
):
    """Analyze vulnerabilities for trends, patterns, and risks."""
    try:
        if not vulnerability_service:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Vulnerability service not available"
            )
        
        # Start analysis
        analysis_id = await vulnerability_service.start_analysis(request)
        
        # Run analysis in background
        background_tasks.add_task(
            vulnerability_service.execute_analysis, 
            analysis_id
        )
        
        logger.info("Analysis started", 
                   analysis_id=analysis_id,
                   target=request.target)
        
        return AnalysisResult(
            analysis_id=analysis_id,
            status="started",
            message="Analysis started successfully",
            created_at=datetime.utcnow()
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to start analysis", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start analysis: {str(e)}"
        )


@app.get("/api/v1/analyze/{analysis_id}", response_model=AnalysisResult)
async def get_analysis_result(analysis_id: str):
    """Get analysis result by ID."""
    try:
        if not vulnerability_service:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Vulnerability service not available"
            )
        
        result = await vulnerability_service.get_analysis_result(analysis_id)
        
        if not result:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Analysis {analysis_id} not found"
            )
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get analysis result", 
                    analysis_id=analysis_id, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get analysis result: {str(e)}"
        )


@app.get("/api/v1/trends", response_model=List[VulnerabilityTrend])
async def get_vulnerability_trends(
    time_range: str = "7d",
    category: Optional[str] = None
):
    """Get vulnerability trends over time."""
    try:
        if not trend_analyzer:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Trend analyzer not available"
            )
        
        trends = await trend_analyzer.get_trends(
            time_range=time_range,
            category=category
        )
        
        return trends
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get trends", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get trends: {str(e)}"
        )


@app.get("/api/v1/baseline/{target}", response_model=BaselineComparison)
async def get_baseline_comparison(target: str):
    """Get baseline comparison for a target."""
    try:
        if not baseline_service:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Baseline service not available"
            )
        
        comparison = await baseline_service.compare_to_baseline(target)
        
        if not comparison:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"No baseline found for target {target}"
            )
        
        return comparison
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get baseline comparison", 
                    target=target, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get baseline comparison: {str(e)}"
        )


@app.post("/api/v1/baseline/{target}")
async def create_baseline(target: str):
    """Create a new baseline for a target."""
    try:
        if not baseline_service:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Baseline service not available"
            )
        
        baseline_id = await baseline_service.create_baseline(target)
        
        logger.info("Baseline created", target=target, baseline_id=baseline_id)
        
        return {
            "message": f"Baseline created for {target}",
            "baseline_id": baseline_id
        }
        
    except Exception as e:
        logger.error("Failed to create baseline", target=target, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create baseline: {str(e)}"
        )


@app.get("/api/v1/anomalies", response_model=List[AnomalyDetection])
async def get_anomalies(
    time_range: str = "24h",
    severity: Optional[str] = None
):
    """Get detected anomalies."""
    try:
        if not anomaly_detector:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Anomaly detector not available"
            )
        
        anomalies = await anomaly_detector.get_anomalies(
            time_range=time_range,
            severity=severity
        )
        
        return anomalies
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get anomalies", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get anomalies: {str(e)}"
        )


@app.get("/api/v1/risk/{target}", response_model=RiskAssessment)
async def get_risk_assessment(target: str):
    """Get risk assessment for a target."""
    try:
        if not risk_analyzer:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Risk analyzer not available"
            )
        
        assessment = await risk_analyzer.assess_risk(target)
        
        if not assessment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"No risk data found for target {target}"
            )
        
        return assessment
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get risk assessment", 
                    target=target, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get risk assessment: {str(e)}"
        )


@app.get("/api/v1/patterns")
async def get_vulnerability_patterns():
    """Get vulnerability patterns and insights."""
    try:
        if not pattern_analyzer:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Pattern analyzer not available"
            )
        
        patterns = await pattern_analyzer.get_patterns()
        
        return {
            "patterns": patterns,
            "generated_at": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        logger.error("Failed to get patterns", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get patterns: {str(e)}"
        )


@app.get("/api/v1/statistics")
async def get_analysis_statistics():
    """Get vulnerability analysis statistics."""
    try:
        stats = {}
        
        if vulnerability_service:
            stats["vulnerability_service"] = await vulnerability_service.get_statistics()
        
        if trend_analyzer:
            stats["trend_analyzer"] = await trend_analyzer.get_statistics()
        
        if baseline_service:
            stats["baseline_service"] = await baseline_service.get_statistics()
        
        if anomaly_detector:
            stats["anomaly_detector"] = await anomaly_detector.get_statistics()
        
        if risk_analyzer:
            stats["risk_analyzer"] = await risk_analyzer.get_statistics()
        
        return {
            "statistics": stats,
            "generated_at": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        logger.error("Failed to get statistics", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get statistics: {str(e)}"
        )


def main():
    """Main entry point."""
    uvicorn.run(
        "services.vulnerability_analyzer.main:app",
        host=settings.host,
        port=settings.port,
        workers=1,
        log_level=settings.log_level.lower(),
        reload=settings.debug,
        access_log=settings.access_log_enabled,
    )


if __name__ == "__main__":
    main()