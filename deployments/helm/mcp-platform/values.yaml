# Default values for MCP Security Platform
# This is a YAML-formatted file with comprehensive multi-Kubernetes platform support.

# Global configuration
global:
  imageRegistry: "ghcr.io"
  imageNamespace: "ggkunka"
  imagePullSecrets: []
  storageClass: ""
  
# Kubernetes platform detection and configuration
kubernetesFlavorConfig:
  # Vanilla Kubernetes (default)
  vanilla:
    enabled: true
    storageClass: "standard"
    ingressClass: "nginx"
    
  # Red Hat OpenShift
  openshift:
    enabled: false
    storageClass: "ocs-storagecluster-ceph-rbd"
    ingressClass: "openshift-default"
    route:
      enabled: true
      host: "mcp-security.apps.openshift.example.com"
      tls:
        termination: "edge"
        insecureEdgeTerminationPolicy: "Redirect"
    securityContextConstraints:
      create: true
      name: "mcp-platform-scc"
      allowHostDirVolumePlugin: false
      allowHostIPC: false
      allowHostNetwork: false
      allowHostPID: false
      allowHostPorts: false
      allowPrivilegedContainer: false
      allowedCapabilities: []
      defaultAddCapabilities: []
      requiredDropCapabilities: 
        - ALL
      runAsUser:
        type: MustRunAsRange
        uidRangeMin: 1000
        uidRangeMax: 65535
      seLinuxContext:
        type: MustRunAs
      fsGroup:
        type: MustRunAs
        ranges:
          - min: 1000
            max: 65535
    quotas:
      requests.cpu: "10"
      requests.memory: "20Gi"
      limits.cpu: "20"
      limits.memory: "40Gi"
      persistentvolumeclaims: "10"
      
  # Amazon EKS
  eks:
    enabled: false
    storageClass: "gp3"
    ingressClass: "alb"
    serviceAccount:
      annotations:
        eks.amazonaws.com/role-arn: ""  # Set your IRSA role ARN
    alb:
      enabled: true
      scheme: "internet-facing"  # or "internal"
      targetType: "ip"
      certificateArn: ""  # Set your ACM certificate ARN
      sslPolicy: "ELBSecurityPolicy-TLS-1-2-2017-01"
    ebs:
      enabled: true
      encrypted: true
      volumeType: "gp3"
      iops: 3000
      throughput: 125
    nodeSelector:
      node.kubernetes.io/instance-type: "m5.large"
    
  # Microsoft AKS
  aks:
    enabled: false
    storageClass: "managed-premium"
    ingressClass: "azure/application-gateway"
    managedIdentity:
      enabled: false
      clientId: ""  # Set your managed identity client ID
      tenantId: ""  # Set your Azure tenant ID
    appGateway:
      enabled: true
      sslRedirect: true
    disk:
      enabled: true
      priority: "regular"
      storageAccount: "Standard_LRS"
    podAnnotations:
      azure.workload.identity/use: "true"
    nodeSelector:
      kubernetes.azure.com/agentpool: "system"
      
  # Google GKE
  gke:
    enabled: false
    storageClass: "standard-rwo"
    ingressClass: "gce"
    workloadIdentity:
      enabled: false
      serviceAccount: ""  # Set your GCP service account
    gce:
      enabled: true
      staticIp: ""  # Set your reserved static IP name
    disk:
      enabled: true
      type: "pd-standard"
    nodeSelector:
      cloud.google.com/gke-nodepool: "default-pool"

# Security configuration
security:
  # Pod Security Standards (K8s 1.25+)
  podSecurityStandards:
    enforce: "restricted"
    audit: "restricted"
    warn: "restricted"
    
  # Pod Security Policy (K8s < 1.25)
  podSecurityPolicy:
    enabled: false
    name: "mcp-platform-psp"
    
  # Security contexts
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  runAsNonRoot: true
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  
  # Network policies
  networkPolicy:
    enabled: true
    ingress:
      - from:
          - namespaceSelector:
              matchLabels:
                name: ingress-nginx
          - namespaceSelector:
              matchLabels:
                name: monitoring
          - podSelector: {}
        ports:
          - protocol: TCP
            port: 8080
    egress:
      - to: []
        ports:
          - protocol: TCP
            port: 53
          - protocol: UDP
            port: 53
          - protocol: TCP
            port: 443
          - protocol: TCP
            port: 80
      - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system

# Service configuration for MCP Platform microservices
services:
  # Ingestion Service
  ingestion:
    enabled: true
    replicaCount: 2
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-ingestion-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8080
      targetPort: 8080
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 10
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    healthcheck:
      enabled: true
      path: "/health/live"
      initialDelaySeconds: 30
      periodSeconds: 10
    env:
      INGESTION_HOST: "0.0.0.0"
      INGESTION_PORT: "8080"
      LOG_LEVEL: "info"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"
      
  # Enrichment Service  
  enrichment:
    enabled: true
    replicaCount: 3
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-enrichment-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8082
      targetPort: 8082
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
    autoscaling:
      enabled: true
      minReplicas: 3
      maxReplicas: 15
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    healthcheck:
      enabled: true
      path: "/health/live"
      initialDelaySeconds: 60
      periodSeconds: 15
    env:
      ENRICHMENT_HOST: "0.0.0.0"
      ENRICHMENT_PORT: "8082"
      LOG_LEVEL: "info"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"
      MAX_CONCURRENT_TASKS: "10"
      ENRICHMENT_TIMEOUT: "300"
      CACHE_TTL: "3600"
    secrets:
      # Threat intelligence API keys (set these in your values override)
      MISP_API_KEY: ""
      VIRUSTOTAL_API_KEY: ""
      OTX_API_KEY: ""
      URLVOID_API_KEY: ""
      
  # Analysis Service
  analysis:
    enabled: true
    replicaCount: 2
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-analysis-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8083
      targetPort: 8083
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 10
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    env:
      ANALYSIS_HOST: "0.0.0.0"
      ANALYSIS_PORT: "8083"
      LOG_LEVEL: "info"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"
      
  # Notification Service
  notification:
    enabled: true
    replicaCount: 2
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-notification-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8084
      targetPort: 8084
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 8
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    env:
      NOTIFICATION_HOST: "0.0.0.0"
      NOTIFICATION_PORT: "8084"
      LOG_LEVEL: "info"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"
    secrets:
      # Notification channel secrets
      SMTP_PASSWORD: ""
      SLACK_TOKEN: ""
      TEAMS_WEBHOOK_URL: ""
      
  # Authentication Service
  auth:
    enabled: true
    replicaCount: 2
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-auth-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8001
      targetPort: 8001
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 8
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    env:
      AUTH_HOST: "0.0.0.0"
      AUTH_PORT: "8001"
      LOG_LEVEL: "info"
      DATABASE_URL: "postgresql://mcp_user:mcp_password@mcp-platform-postgresql:5432/mcp_security"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"
    secrets:
      JWT_SECRET_KEY: ""
      DATABASE_PASSWORD: ""
      
  # Gateway Service
  gateway:
    enabled: true
    replicaCount: 2
    image:
      repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-gateway-service"
      tag: "1.0.0"
      pullPolicy: IfNotPresent
    service:
      type: ClusterIP
      port: 8000
      targetPort: 8000
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 10
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    env:
      GATEWAY_HOST: "0.0.0.0"
      GATEWAY_PORT: "8000"
      LOG_LEVEL: "info"
      REDIS_URL: "redis://mcp-platform-redis-master:6379/0"

# Infrastructure dependencies
redis:
  enabled: true
  architecture: "replication"
  auth:
    enabled: true
    password: "mcp-redis-password"
  master:
    persistence:
      enabled: true
      size: 10Gi
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
  replica:
    replicaCount: 1
    persistence:
      enabled: true
      size: 10Gi
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

postgresql:
  enabled: true
  auth:
    postgresPassword: "mcp-postgres-admin"
    username: "mcp_user"
    password: "mcp-password"
    database: "mcp_security"
  primary:
    persistence:
      enabled: true
      size: 20Gi
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
  readReplicas:
    replicaCount: 1
    persistence:
      enabled: true
      size: 20Gi
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

# Ingress configuration
ingress:
  enabled: true
  className: ""  # Will be set by platform detection
  annotations: {}  # Will be populated by platform-specific helpers
  hosts:
    - host: mcp-security.local
      paths:
        - path: /
          pathType: Prefix
          service:
            name: mcp-platform-gateway
            port: 8000
  tls:
    - secretName: mcp-platform-tls
      hosts:
        - mcp-security.local

# Monitoring configuration
monitoring:
  enabled: true
  port: 8080
  path: "/metrics"
  
  prometheus:
    enabled: false  # Set to true if you want to install Prometheus
    serviceMonitor:
      enabled: true
      interval: 30s
      scrapeTimeout: 10s
      
  grafana:
    enabled: false  # Set to true if you want to install Grafana
    dashboards:
      enabled: true
      
  openshift:
    enabled: false
    annotations:
      prometheus.openshift.io/scrape: "true"
      prometheus.openshift.io/port: "8080"

# Resource quotas
resourceQuota:
  enabled: false
  hard:
    requests.cpu: "10"
    requests.memory: "20Gi"
    limits.cpu: "20"
    limits.memory: "40Gi"
    persistentvolumeclaims: "10"

# Pod disruption budgets
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Service account configuration
serviceAccount:
  create: true
  annotations: {}  # Will be populated by platform-specific helpers
  name: ""
  automountServiceAccountToken: true

# RBAC configuration
rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["secrets", "configmaps", "pods", "services"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["apps"]
      resources: ["deployments", "replicasets"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["batch"]
      resources: ["jobs", "cronjobs"]
      verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
    - apiGroups: ["networking.k8s.io"]
      resources: ["networkpolicies"]
      verbs: ["get", "list", "watch"]

# External dependencies (if you don't want to use the bundled ones)
externalRedis:
  enabled: false
  connectionString: ""
  
externalPostgresql:
  enabled: false
  connectionString: ""

# Backup configuration
backup:
  enabled: false
  schedule: "0 2 * * *"
  retention: "7d"
  storage:
    size: 50Gi
    storageClass: ""

# Migration job
migration:
  enabled: true
  image:
    repository: "{{ .Values.global.imageRegistry }}/{{ .Values.global.imageNamespace }}/mcp-auth-service"
    tag: "1.0.0"
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "500m"

# Node affinity and tolerations
nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - mcp-platform
          topologyKey: kubernetes.io/hostname

# Global overrides
nameOverride: ""
fullnameOverride: ""